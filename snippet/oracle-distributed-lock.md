# 基于 Oracle 数据库 实现分布式锁

> 在进行对旧系统重构时, 因为需要存在旧系统多个节点同时跑任务的情况, 因此为了确保多个节点同一时刻只能有一个节点处理任务, 其它节点不进行处理, 且旧系统技术老旧, 没有对Redis相关的依赖和配置, 因此设计实现了基于数据库的分布式锁, 该锁有超时时间, 确保某个节点即使因为特殊原因未释放, 也不影响其它节点获取该锁, 之后我抽空将相关逻辑在新系统也重写了一遍, 新系统里也可使用,因为存在新旧系统并行跑的情况. 现将新系统里的这个锁实现记录下, 后续旧系统彻底淘汰后这部分的代码应该也就没有存在意义了. 直接都使用Redis分布式锁就可以了

## 业务代码
### 数据库表 DDL
``` sql
CREATE TABLE "TBL_PESSIMISTIC_LOCK" (
"LOCK_NAME" VARCHAR2(64 BYTE) NOT NULL,
"LOCK_TIME" TIMESTAMP(0) NOT NULL,
"LOCK_HOLDER" VARCHAR2(64 BYTE) NOT NULL,
"EXPIRED_TIME" TIMESTAMP(0) NOT NULL,
"LOCK_STATUS" NUMBER(1,0) DEFAULT 0  NOT NULL,
CONSTRAINT "SYS_C0085128" PRIMARY KEY ("LOCK_NAME") 
)
TABLESPACE SWTSETTLE
LOGGING
NOCOMPRESS 
NOCACHE
NOPARALLEL ;
ALTER TABLE "TBL_PESSIMISTIC_LOCK" ADD CONSTRAINT "SYS_C0085126" CHECK ("LOCK_NAME" IS NOT NULL) ENABLE;
ALTER TABLE "TBL_PESSIMISTIC_LOCK" ADD CONSTRAINT "SYS_C0085127" CHECK ("LOCK_TIME" IS NOT NULL) ENABLE;
ALTER TABLE "TBL_PESSIMISTIC_LOCK" ADD CONSTRAINT "SYS_C0085129" CHECK ("LOCK_HOLDER" IS NOT NULL) ENABLE;
ALTER TABLE "TBL_PESSIMISTIC_LOCK" ADD CONSTRAINT "SYS_C0085130" CHECK ("EXPIRED_TIME" IS NOT NULL) ENABLE;
ALTER TABLE "TBL_PESSIMISTIC_LOCK" ADD CONSTRAINT "SYS_C0085133" CHECK ("LOCK_STATUS" IS NOT NULL) ENABLE;
COMMENT ON TABLE "TBL_PESSIMISTIC_LOCK" IS 'DB悲观锁实现';
COMMENT ON COLUMN "TBL_PESSIMISTIC_LOCK"."LOCK_NAME" IS '锁的标识';
COMMENT ON COLUMN "TBL_PESSIMISTIC_LOCK"."LOCK_TIME" IS '被锁时间';
COMMENT ON COLUMN "TBL_PESSIMISTIC_LOCK"."LOCK_HOLDER" IS '锁持有人';
COMMENT ON COLUMN "TBL_PESSIMISTIC_LOCK"."EXPIRED_TIME" IS '过期时间';
COMMENT ON COLUMN "TBL_PESSIMISTIC_LOCK"."LOCK_STATUS" IS '锁的状态';
```
### MyBatis Mapper
> 对于数据持久层 新系统里 Jpa 和 Mybatis 都使用了, 这种特殊的SQL 使用Mybatis比较方便些. Mapper 和 对应的 XML 如下.
``` java
import org.apache.ibatis.annotations.Param;

/**
 * TBL_PESSIMISTIC_LOCK DB悲观锁实现 复杂查询构建 Mapper
 * Mapper generated by OracleDDl2DaoGenerator
 * @author derick.jin 2019-11-06 14:38:06
 * @version 1.0
 **/
public interface TblPessimisticLockMapper {
    /**
     * 竞争锁 只依赖数据库时间
     * 如果数据库的锁过期 或 锁空闲 则可以正常更新获得锁，否则更新失败
     * @param lockName 锁标识
     * @param lockHolder 竞争人 竞争成功则是持有人
     * @param overTime 超时时间 毫秒
     * @return 影响记录数 0-获得锁失败 1-获得锁成功
     */
    Integer competeLock(@Param("lockName") String lockName, @Param("lockHolder") String lockHolder, @Param("overTime") Long overTime);

    /**
     * 释放锁
     * 将锁标识对应的锁 且是锁定状态 且由当前系统持有的 锁 标记为 未锁定
     * @param lockName 锁标识
     * @param lockHolder 锁持有人
     * @return 影响记录数 0-释放锁失败（可能锁已经超时被其他人重新持有） 1-释放锁成功
     */
    Integer releaseLock(@Param("lockName") String lockName, @Param("lockHolder") String lockHolder);

    /**
     * 初始化锁 只依赖数据库时间
     * 再该锁的首次执行时 需要调用此方法创建一条锁记录在表中
     * 主键冲突异常：添加锁失败（可能同时有多个人在初始化同一个锁）
     * @param lockName 锁标识
     * @param lockHolder 竞争人 竞争成功则是持有人
     * @param overTime 超时时间 毫秒
     */
    Integer initializeLock(@Param("lockName") String lockName, @Param("lockHolder") String lockHolder, @Param("overTime") Long overTime);
}
```
### MyBatis SQL
``` xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--
  Table    : SWTSETTLE.TBL_PESSIMISTIC_LOCK
  Comment  : DB悲观锁实现
  Mapper   : com.cil.settle.mapper.setdb.TblPessimisticLockMapper
  Author   : derick.jin generated by OracleDDl2DaoGenerator
  CreateAt : 2019-11-06 14:38:06
-->
<mapper namespace="com.cil.settle.mapper.setdb.TblPessimisticLockMapper">
    <!-- ResultMap: 表结构和实体的默认映射关系 实体属性名和数据表名可能不一致 -->
    <resultMap id="resultMapDefault" type="com.cil.settle.entity.po.setdb.TblPessimisticLock" >
        <!-- Comment: 主键 锁的标识 -->
        <id column="LOCK_NAME" property="lockName" javaType="java.lang.String"/>
        <!-- Comment: 主键 被锁时间 -->
        <result column="LOCK_TIME" property="lockTime" javaType="java.util.Date"/>
        <!-- Comment: 锁持有人 -->
        <result column="LOCK_HOLDER" property="lockHolder" javaType="java.lang.String"/>
        <!-- Comment: 过期时间 -->
        <result column="EXPIRED_TIME" property="expiredTime" javaType="java.util.Date"/>
        <!-- Comment: 锁的状态 0-未锁 1-已锁 -->
        <result column="LOCK_STATUS" property="lockStatus" javaType="java.lang.Integer"/>
    </resultMap>

    <update id="competeLock">
        update TBL_PESSIMISTIC_LOCK
        set LOCK_HOLDER = #{lockHolder},
            LOCK_STATUS = 1,
            LOCK_TIME = SYSDATE,
            EXPIRED_TIME = SYSDATE + #{overTime} /24/60/60/1000
        where LOCK_NAME = #{lockName}
          and (LOCK_STATUS = 0 or SYSDATE > EXPIRED_TIME)
    </update>

    <update id="releaseLock">
        update TBL_PESSIMISTIC_LOCK
        set LOCK_STATUS = 0
        where LOCK_NAME = #{lockName}
          and LOCK_HOLDER = #{lockHolder}
          and LOCK_STATUS = 1
    </update>

    <insert id="initializeLock">
        insert into TBL_PESSIMISTIC_LOCK(LOCK_NAME, LOCK_TIME, LOCK_HOLDER, EXPIRED_TIME, LOCK_STATUS)
        values (#{lockName}, SYSDATE, #{lockHolder}, SYSDATE + #{overTime} /24/60/60/1000, 1)
    </insert>
</mapper>
```
### 使用枚举 管理锁定义
> 为了便于在项目中管理使用的所有锁的信息, 使用枚举类来管理锁的定义, 这样便于系统对这部分的维护和管理.
``` java
import lombok.AllArgsConstructor;
import lombok.Getter;

/**
 * 悲观锁定义枚举
 * @author derick.jin 2019-11-06 10:59:00
 * @version 1.0
 **/
@Getter
@AllArgsConstructor
public enum PessimisticLockEnum {
    /**
     * 定时任务每 1 分钟会查询一次数据库表创建未来 1 分钟的调度任务，为防止分布式系统中出现重复创建任务的问题，执行前加锁
     */
    TASK_PRODUCER_LOCK("TIMER_TASK_GET_LOCK", 30 * 1000L, 0, 5 * 1000L),
    
    ;
    /**
     * 锁名称 唯一字段
     */
    private String lockName;
    /**
     * 锁过期时间 毫秒
     * 如不手动解除锁, 超时时间后会自动认定锁过期 可被重新获得
     */
    private Long overTime;
    /**
     * 锁尝试获取次数
     */
    private Integer retryCount;
    /**
     * 锁尝试获取间隔 毫秒
     * 获取锁失败会立即进行 retryInterval 的线程休眠
     */
    private Long retryInterval;
}
```
### 业务接口
> 业务接口和业务实现代码如下.
``` java
import com.cil.settle.dictionary.manager.PessimisticLockEnum;

/**
 * 基于 Oracle 实现的分布式锁 业务接口
 * @author derick.jin 2019-11-06 10:57:00
 * @version 1.0
 **/
public interface OracleDistributedLockService {

    /**
     * 添加锁
     * @param pessimisticLock 悲观锁枚举
     */
    void doLock(PessimisticLockEnum pessimisticLock);

    /**
     * 添加锁
     * 使用自定义的 重试配置 而非枚举中的默认配置
     * @param pessimisticLock 悲观锁枚举
     * @param retryCount 重试次数
     * @param retryInterval 重试时间间隔
     */
    void doLock(PessimisticLockEnum pessimisticLock, Long overTime, Integer retryCount, Long retryInterval);

    /**
     * 释放锁
     * @param pessimisticLock
     */
    void unLock(PessimisticLockEnum pessimisticLock);

    /**
     * 自动添加和释放锁
     * 如果竞争到锁，获取锁，执行 onSuccess 回调，并自动释放锁
     * 如果多次尝试竞争锁均失败，则执行 onFailure 回调，在枚举中配置的有 尝试次数和间隔
     * @param pessimisticLock 悲观锁枚举
     * @param onSuccess 成功回调
     * @param onFailure 失败回调
     */
    void autoLock(PessimisticLockEnum pessimisticLock, Runnable onSuccess, Runnable onFailure);
}
```
### 业务实现
``` java

import com.cil.settle.dictionary.manager.PessimisticLockEnum;
import com.cil.settle.entity.po.setdb.TblPessimisticLock;
import com.cil.settle.manager.service.OracleDistributedLockService;
import com.cil.settle.mapper.setdb.TblPessimisticLockMapper;
import com.cil.settle.repository.setdb.TblPessimisticLockRepository;
import com.cil.settle.util.DateUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

/**
 * 基于 Oracle 实现的分布式锁 业务实现
 *
 * @author derick.jin 2019-11-06 14:10:00
 * @version 1.0
 **/
@Slf4j
@Service
public class OracleDistributedLockServiceImpl implements OracleDistributedLockService {

    @Autowired
    private TblPessimisticLockRepository pessimisticLockRepository;

    @Autowired
    private TblPessimisticLockMapper pessimisticLockMapper;

	// 确保每个节点的 server.name 不一样, 这里新系统在使用Docker run 镜像时 使用 -e 命令指定该参数的唯一配置, 因此此值才可作为锁的持有人标识, 如果嫌麻烦在配置文件里使用 Spring 的随机数配置个值也可.
    @Value("${server.name}")
    private String serverName;

    /**
     * 获取锁持有人信息
     * @return 持有人标识
     */
    private String getLockHolder() {
        return serverName;
    }

    /**
     * 添加锁
     *
     * @param pessimisticLock 悲观锁枚举
     */
    @Override
    @Transactional
    public void doLock(PessimisticLockEnum pessimisticLock) {
        doLock(pessimisticLock, pessimisticLock.getOverTime(), pessimisticLock.getRetryCount(), pessimisticLock.getRetryInterval());
    }

    /**
     * 添加锁
     * 使用自定义的 重试配置 而非枚举中的默认配置
     *
     * @param pessimisticLock 悲观锁枚举
     * @param overTime        超时时间 毫秒
     * @param retryCount      重试次数
     * @param retryInterval   重试时间间隔
     */
    @Override
    @Transactional
    public void doLock(PessimisticLockEnum pessimisticLock, Long overTime, Integer retryCount, Long retryInterval) {
        // 判断锁是否存在
        Optional<TblPessimisticLock> lock = pessimisticLockRepository.findById(pessimisticLock.getLockName());
        if (!lock.isPresent()) {
            try {
                // 如果不存在则初始化锁
                Integer isSuccess = pessimisticLockMapper.initializeLock(pessimisticLock.getLockName(), getLockHolder(), pessimisticLock.getOverTime());
                // 初始化并获取锁成功
                if (isSuccess == 1) {
                    return;
                }
            } catch (DuplicateKeyException e) {
                log.warn("Initialize Lock Failed, may Initialized by other");
            }
        }
        // 开始有限次数的锁竞争
        int sumTryCount = 1 + retryCount;
        for (int tryCount = 1; tryCount <= sumTryCount ; tryCount++) {
            Integer isSuccess = pessimisticLockMapper.competeLock(pessimisticLock.getLockName(), getLockHolder(), pessimisticLock.getOverTime());
            // 竞争锁成功
            if (isSuccess == 1) {
                return;
            }
            // 最后一次如果仍未竞争成功 不再休眠
            if (tryCount == sumTryCount) {
                break;
            }
            // 竞争锁失败 线程休眠
            try {
                Thread.sleep(retryInterval);
            } catch (InterruptedException e) {
                // 异常休眠中断 抛出异常
                throw new IllegalStateException(String.format("Lock:%s Retry:%d Interval Waiting Failed", pessimisticLock.getLockName(), tryCount), e);
            }
        }
        // 未竞争到锁 抛出异常
        throw new IllegalStateException(String.format("doLock FailedAt:%s retry count:%d", DateUtil.format(), retryCount));
    }

    /**
     * 释放锁
     *
     * @param pessimisticLock 悲观锁枚举
     */
    @Override
    @Transactional
    public void unLock(PessimisticLockEnum pessimisticLock) {
        Integer isSuccess = pessimisticLockMapper.releaseLock(pessimisticLock.getLockName(), getLockHolder());
        if (isSuccess == 1) {
            log.info("释放锁成功");
        } else {
            log.warn("unLock:{} may expired, reference {} records", pessimisticLock.getLockName(), isSuccess);
        }
    }

    /**
     * 自动添加和释放锁
     * 如果竞争到锁，获取锁，执行 onSuccess 回调，并自动释放锁
     * 如果多次尝试竞争锁均失败，则执行 onFailure 回调，在枚举中配置的有 尝试次数和间隔
     *
     * @param pessimisticLock 悲观锁枚举
     * @param onSuccess       成功回调
     * @param onFailure       失败回调
     */
    @Override
    public void autoLock(PessimisticLockEnum pessimisticLock, Runnable onSuccess, Runnable onFailure) {
        // 尝试获取锁
        try {
            doLock(pessimisticLock);
            log.info("获取锁成功");
        } catch (Exception e) {
            log.error("获取锁失败", e);
            // 获取锁失败
            onFailure.run();
            return;
        }

        // 执行成功回调
        try {
            onSuccess.run();
        } finally {
            // 一定释放锁
            unLock(pessimisticLock);
        }
    }
}
```
## 测试代码

``` java
import com.cil.settle.CilSettleBootstrapApplication;
import com.cil.settle.dictionary.manager.PessimisticLockEnum;
import com.cil.settle.manager.service.OracleDistributedLockService;
import lombok.extern.slf4j.Slf4j;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

/**
 * @author derick.jin 2019-11-06 15:42:00
 * @version 1.0
 **/
@Slf4j
@RunWith(SpringRunner.class)
@SpringBootTest(classes={CilSettleBootstrapApplication.class})
public class OracleDistributedLockServiceTest {

    @Autowired
    private OracleDistributedLockService oracleDistributedLockService;

    @Test
    public void doTest(){
        // 模拟三个线程同时竞争锁
        for (int i = 0; i < 3; i++) {
            new Thread(()->{
                oracleDistributedLockService.autoLock(PessimisticLockEnum.TASK_PRODUCER_LOCK, () -> {
                    log.info("Thread get lock success");
                    try {
                        Thread.sleep(3000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }, () -> {
                    log.error("Thread get lock failed");
                });
            }).start();
        }
        // 防止测试主线程提前结束
        try {
            Thread.sleep(60000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```
